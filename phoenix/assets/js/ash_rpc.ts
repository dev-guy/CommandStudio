// Generated by AshTypescript
// Do not edit this file manually





export type UUID = string;
export type UtcDateTimeUsec = string;

// Environment Schema
export type EnvironmentResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "enabled";
  id: UUID;
  name: string;
  enabled: boolean;
  commandSchedules: { __type: "Relationship"; __array: true; __resource: CommandScheduleResourceSchema; };
  variables: { __type: "Relationship"; __array: true; __resource: VariableResourceSchema; };
  commandScheduleEnvironments: { __type: "Relationship"; __array: true; __resource: CommandScheduleEnvironmentResourceSchema; };
  commandJobs: { __type: "Relationship"; __array: true; __resource: CommandJobResourceSchema; };
  variableEnvironments: { __type: "Relationship"; __array: true; __resource: VariableEnvironmentResourceSchema; };
};



export type EnvironmentAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "enabled";
  id: UUID;
  name: string;
  enabled: boolean;
};


// Cron Schema
export type CronResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "crontabExpression" | "enabled";
  id: UUID;
  name: string;
  crontabExpression: string;
  enabled: boolean;
  commandSchedules: { __type: "Relationship"; __array: true; __resource: CommandScheduleResourceSchema; };
  commandScheduleCrons: { __type: "Relationship"; __array: true; __resource: CommandScheduleCronResourceSchema; };
  commandJobs: { __type: "Relationship"; __array: true; __resource: CommandJobResourceSchema; };
};



export type CronAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "crontabExpression" | "enabled";
  id: UUID;
  name: string;
  crontabExpression: string;
  enabled: boolean;
};


// CommandSchedule Schema
export type CommandScheduleResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "enabled" | "commandId";
  id: UUID;
  enabled: boolean;
  commandId: UUID;
  command: { __type: "Relationship"; __resource: CommandResourceSchema; };
  environments: { __type: "Relationship"; __array: true; __resource: EnvironmentResourceSchema; };
  crons: { __type: "Relationship"; __array: true; __resource: CronResourceSchema; };
  commandScheduleEnvironments: { __type: "Relationship"; __array: true; __resource: CommandScheduleEnvironmentResourceSchema; };
  commandScheduleCrons: { __type: "Relationship"; __array: true; __resource: CommandScheduleCronResourceSchema; };
};



export type CommandScheduleAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "enabled" | "commandId";
  id: UUID;
  enabled: boolean;
  commandId: UUID;
};


// CommandScheduleEnvironment Schema
export type CommandScheduleEnvironmentResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "commandScheduleId" | "environmentId";
  id: UUID;
  commandScheduleId: UUID;
  environmentId: UUID;
  commandSchedule: { __type: "Relationship"; __resource: CommandScheduleResourceSchema; };
  environment: { __type: "Relationship"; __resource: EnvironmentResourceSchema; };
};



export type CommandScheduleEnvironmentAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "commandScheduleId" | "environmentId";
  id: UUID;
  commandScheduleId: UUID;
  environmentId: UUID;
};


// CommandScheduleCron Schema
export type CommandScheduleCronResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "commandScheduleId" | "cronId";
  id: UUID;
  commandScheduleId: UUID;
  cronId: UUID;
  commandSchedule: { __type: "Relationship"; __resource: CommandScheduleResourceSchema; };
  cron: { __type: "Relationship"; __resource: CronResourceSchema; };
};



export type CommandScheduleCronAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "commandScheduleId" | "cronId";
  id: UUID;
  commandScheduleId: UUID;
  cronId: UUID;
};


// Variable Schema
export type VariableResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name";
  id: UUID;
  name: string;
  environments: { __type: "Relationship"; __array: true; __resource: EnvironmentResourceSchema; };
  variableEnvironments: { __type: "Relationship"; __array: true; __resource: VariableEnvironmentResourceSchema; };
};



export type VariableAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name";
  id: UUID;
  name: string;
};


// VariableEnvironment Schema
export type VariableEnvironmentResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "regularValue" | "variableId" | "environmentId" | "secretValue";
  id: UUID;
  regularValue: string | null;
  variableId: UUID;
  environmentId: UUID;
  secretValue: string | null;
  variable: { __type: "Relationship"; __resource: VariableResourceSchema; };
  environment: { __type: "Relationship"; __resource: EnvironmentResourceSchema; };
};



export type VariableEnvironmentAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "regularValue" | "variableId" | "environmentId";
  id: UUID;
  regularValue: string | null;
  variableId: UUID;
  environmentId: UUID;
};


// Command Schema
export type CommandResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "shellCommand" | "enabled" | "timeoutMs";
  id: UUID;
  name: string;
  shellCommand: string;
  enabled: boolean;
  timeoutMs: number;
  commandJobs: { __type: "Relationship"; __array: true; __resource: CommandJobResourceSchema; };
  commandSchedules: { __type: "Relationship"; __array: true; __resource: CommandScheduleResourceSchema; };
};



export type CommandAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "shellCommand" | "enabled" | "timeoutMs";
  id: UUID;
  name: string;
  shellCommand: string;
  enabled: boolean;
  timeoutMs: number;
};


// CommandJobEvent Schema
export type CommandJobEventResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "status" | "startedAt" | "finishedAt" | "durationMs" | "stdout" | "stderr" | "createdAt" | "commandJobId";
  id: UUID;
  status: string;
  startedAt: UtcDateTimeUsec | null;
  finishedAt: UtcDateTimeUsec | null;
  durationMs: number | null;
  stdout: string;
  stderr: string;
  createdAt: UtcDateTimeUsec;
  commandJobId: UUID;
  commandJob: { __type: "Relationship"; __resource: CommandJobResourceSchema; };
};



export type CommandJobEventAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "status" | "startedAt" | "finishedAt" | "durationMs" | "stdout" | "stderr" | "createdAt" | "commandJobId";
  id: UUID;
  status: string;
  startedAt: UtcDateTimeUsec | null;
  finishedAt: UtcDateTimeUsec | null;
  durationMs: number | null;
  stdout: string;
  stderr: string;
  createdAt: UtcDateTimeUsec;
  commandJobId: UUID;
};


// CommandJob Schema
export type CommandJobResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "obanJobId" | "shellCommand" | "cronExpression" | "startedAt" | "finishedAt" | "commandId" | "environmentId" | "cronId";
  id: UUID;
  obanJobId: number | null;
  shellCommand: string;
  cronExpression: string;
  startedAt: UtcDateTimeUsec | null;
  finishedAt: UtcDateTimeUsec | null;
  commandId: UUID;
  environmentId: UUID;
  cronId: UUID | null;
  command: { __type: "Relationship"; __resource: CommandResourceSchema; };
  environment: { __type: "Relationship"; __resource: EnvironmentResourceSchema; };
  cron: { __type: "Relationship"; __resource: CronResourceSchema | null; };
  commandJobEvents: { __type: "Relationship"; __array: true; __resource: CommandJobEventResourceSchema; };
};



export type CommandJobAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "obanJobId" | "shellCommand" | "cronExpression" | "startedAt" | "finishedAt" | "commandId" | "environmentId" | "cronId";
  id: UUID;
  obanJobId: number | null;
  shellCommand: string;
  cronExpression: string;
  startedAt: UtcDateTimeUsec | null;
  finishedAt: UtcDateTimeUsec | null;
  commandId: UUID;
  environmentId: UUID;
  cronId: UUID | null;
};




export type EnvironmentFilterInput = {
  and?: Array<EnvironmentFilterInput>;
  or?: Array<EnvironmentFilterInput>;
  not?: Array<EnvironmentFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  enabled?: {
    eq?: boolean;
    notEq?: boolean;
  };


  commandSchedules?: CommandScheduleFilterInput;

  variables?: VariableFilterInput;

  commandScheduleEnvironments?: CommandScheduleEnvironmentFilterInput;

  commandJobs?: CommandJobFilterInput;

  variableEnvironments?: VariableEnvironmentFilterInput;

};
export type CronFilterInput = {
  and?: Array<CronFilterInput>;
  or?: Array<CronFilterInput>;
  not?: Array<CronFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  crontabExpression?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  enabled?: {
    eq?: boolean;
    notEq?: boolean;
  };


  commandSchedules?: CommandScheduleFilterInput;

  commandScheduleCrons?: CommandScheduleCronFilterInput;

  commandJobs?: CommandJobFilterInput;

};
export type CommandScheduleFilterInput = {
  and?: Array<CommandScheduleFilterInput>;
  or?: Array<CommandScheduleFilterInput>;
  not?: Array<CommandScheduleFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  enabled?: {
    eq?: boolean;
    notEq?: boolean;
  };

  commandId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  command?: CommandFilterInput;

  environments?: EnvironmentFilterInput;

  crons?: CronFilterInput;

  commandScheduleEnvironments?: CommandScheduleEnvironmentFilterInput;

  commandScheduleCrons?: CommandScheduleCronFilterInput;

};
export type CommandScheduleEnvironmentFilterInput = {
  and?: Array<CommandScheduleEnvironmentFilterInput>;
  or?: Array<CommandScheduleEnvironmentFilterInput>;
  not?: Array<CommandScheduleEnvironmentFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  commandScheduleId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  environmentId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  commandSchedule?: CommandScheduleFilterInput;

  environment?: EnvironmentFilterInput;

};
export type CommandScheduleCronFilterInput = {
  and?: Array<CommandScheduleCronFilterInput>;
  or?: Array<CommandScheduleCronFilterInput>;
  not?: Array<CommandScheduleCronFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  commandScheduleId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  cronId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  commandSchedule?: CommandScheduleFilterInput;

  cron?: CronFilterInput;

};
export type VariableFilterInput = {
  and?: Array<VariableFilterInput>;
  or?: Array<VariableFilterInput>;
  not?: Array<VariableFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };


  environments?: EnvironmentFilterInput;

  variableEnvironments?: VariableEnvironmentFilterInput;

};
export type VariableEnvironmentFilterInput = {
  and?: Array<VariableEnvironmentFilterInput>;
  or?: Array<VariableEnvironmentFilterInput>;
  not?: Array<VariableEnvironmentFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  regularValue?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  variableId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  environmentId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  secretValue?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };


  variable?: VariableFilterInput;

  environment?: EnvironmentFilterInput;

};
export type CommandFilterInput = {
  and?: Array<CommandFilterInput>;
  or?: Array<CommandFilterInput>;
  not?: Array<CommandFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  shellCommand?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  enabled?: {
    eq?: boolean;
    notEq?: boolean;
  };

  timeoutMs?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };


  commandJobs?: CommandJobFilterInput;

  commandSchedules?: CommandScheduleFilterInput;

};
export type CommandJobEventFilterInput = {
  and?: Array<CommandJobEventFilterInput>;
  or?: Array<CommandJobEventFilterInput>;
  not?: Array<CommandJobEventFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  status?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  startedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  finishedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  durationMs?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  stdout?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  stderr?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  createdAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  commandJobId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  commandJob?: CommandJobFilterInput;

};
export type CommandJobFilterInput = {
  and?: Array<CommandJobFilterInput>;
  or?: Array<CommandJobFilterInput>;
  not?: Array<CommandJobFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  obanJobId?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  shellCommand?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  cronExpression?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  startedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  finishedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  commandId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  environmentId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  cronId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  command?: CommandFilterInput;

  environment?: EnvironmentFilterInput;

  cron?: CronFilterInput;

  commandJobEvents?: CommandJobEventFilterInput;

};


// Utility Types

// Resource schema constraint
export type TypedSchema = {
  __type: "Resource" | "TypedMap" | "Union";
  __primitiveFields: string;
};

// Utility type to convert union to intersection
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;

// Helper type to infer union field values, avoiding duplication between array and non-array unions
export type InferUnionFieldValue<
  UnionSchema extends { __type: "Union"; __primitiveFields: any },
  FieldSelection extends any[],
> = UnionToIntersection<
  {
    [FieldIndex in keyof FieldSelection]: FieldSelection[FieldIndex] extends UnionSchema["__primitiveFields"]
      ? FieldSelection[FieldIndex] extends keyof UnionSchema
        ? { [P in FieldSelection[FieldIndex]]: UnionSchema[FieldSelection[FieldIndex]] }
        : never
      : FieldSelection[FieldIndex] extends Record<string, any>
        ? {
            [UnionKey in keyof FieldSelection[FieldIndex]]: UnionKey extends keyof UnionSchema
              ? NonNullable<UnionSchema[UnionKey]> extends { __array: true; __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
                ? FieldSelection[FieldIndex][UnionKey] extends any[]
                  ? Array<
                      UnionToIntersection<
                        {
                          [FieldIdx in keyof FieldSelection[FieldIndex][UnionKey]]: FieldSelection[FieldIndex][UnionKey][FieldIdx] extends TypedMapFields
                            ? FieldSelection[FieldIndex][UnionKey][FieldIdx] extends keyof NonNullable<UnionSchema[UnionKey]>
                              ? { [P in FieldSelection[FieldIndex][UnionKey][FieldIdx]]: NonNullable<UnionSchema[UnionKey]>[P] }
                              : never
                            : never;
                        }[number]
                      >
                    > | null
                  : never
                : NonNullable<UnionSchema[UnionKey]> extends { __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
                  ? FieldSelection[FieldIndex][UnionKey] extends any[]
                    ? UnionToIntersection<
                        {
                          [FieldIdx in keyof FieldSelection[FieldIndex][UnionKey]]: FieldSelection[FieldIndex][UnionKey][FieldIdx] extends TypedMapFields
                            ? FieldSelection[FieldIndex][UnionKey][FieldIdx] extends keyof NonNullable<UnionSchema[UnionKey]>
                              ? { [P in FieldSelection[FieldIndex][UnionKey][FieldIdx]]: NonNullable<UnionSchema[UnionKey]>[P] }
                              : never
                            : never;
                        }[number]
                      > | null
                    : never
                  : NonNullable<UnionSchema[UnionKey]> extends TypedSchema
                    ? InferResult<NonNullable<UnionSchema[UnionKey]>, FieldSelection[FieldIndex][UnionKey]>
                    : never
              : never;
          }
        : never;
  }[number]
>;

export type HasComplexFields<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
> extends never
  ? false
  : true;

export type ComplexFieldKeys<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
>;

export type LeafFieldSelection<T extends TypedSchema> = T["__primitiveFields"];

export type ComplexFieldSelection<T extends TypedSchema> = {
  [K in ComplexFieldKeys<T>]?: T[K] extends {
    __type: "Relationship";
    __resource: infer Resource;
  }
    ? NonNullable<Resource> extends TypedSchema
      ? UnifiedFieldSelection<NonNullable<Resource>>[]
      : never
    : T[K] extends {
          __type: "ComplexCalculation";
          __returnType: infer ReturnType;
        }
      ? T[K] extends { __args: infer Args }
        ? NonNullable<ReturnType> extends TypedSchema
          ? {
              args: Args;
              fields: UnifiedFieldSelection<NonNullable<ReturnType>>[];
            }
          : { args: Args }
        : NonNullable<ReturnType> extends TypedSchema
          ? { fields: UnifiedFieldSelection<NonNullable<ReturnType>>[] }
          : never
      : T[K] extends { __type: "TypedMap" }
        ? NonNullable<T[K]> extends TypedSchema
          ? UnifiedFieldSelection<NonNullable<T[K]>>[]
          : never
        : T[K] extends { __type: "Union"; __primitiveFields: infer PrimitiveFields }
          ? T[K] extends { __array: true }
            ? (PrimitiveFields | {
                [UnionKey in keyof Omit<T[K], "__type" | "__primitiveFields" | "__array">]?: NonNullable<T[K][UnionKey]> extends { __type: "TypedMap"; __primitiveFields: any }
                  ? NonNullable<T[K][UnionKey]>["__primitiveFields"][]
                  : NonNullable<T[K][UnionKey]> extends TypedSchema
                    ? UnifiedFieldSelection<NonNullable<T[K][UnionKey]>>[]
                    : never;
              })[]
            : (PrimitiveFields | {
                [UnionKey in keyof Omit<T[K], "__type" | "__primitiveFields">]?: NonNullable<T[K][UnionKey]> extends { __type: "TypedMap"; __primitiveFields: any }
                  ? NonNullable<T[K][UnionKey]>["__primitiveFields"][]
                  : NonNullable<T[K][UnionKey]> extends TypedSchema
                    ? UnifiedFieldSelection<NonNullable<T[K][UnionKey]>>[]
                    : never;
              })[]
            : NonNullable<T[K]> extends TypedSchema
              ? UnifiedFieldSelection<NonNullable<T[K]>>[]
              : never;
};

// Main type: Use explicit base case detection to prevent infinite recursion
export type UnifiedFieldSelection<T extends TypedSchema> =
  HasComplexFields<T> extends false
    ? LeafFieldSelection<T> // Base case: only primitives, no recursion
    : LeafFieldSelection<T> | ComplexFieldSelection<T>; // Recursive case

export type InferFieldValue<
  T extends TypedSchema,
  Field,
> = Field extends T["__primitiveFields"]
  ? Field extends keyof T
    ? { [K in Field]: T[Field] }
    : never
  : Field extends Record<string, any>
    ? {
        [K in keyof Field]: K extends keyof T
          ? T[K] extends {
              __type: "Relationship";
              __resource: infer Resource;
            }
            ? NonNullable<Resource> extends TypedSchema
              ? T[K] extends { __array: true }
                ? Array<InferResult<NonNullable<Resource>, Field[K]>>
                : null extends Resource
                  ? InferResult<NonNullable<Resource>, Field[K]> | null
                  : InferResult<NonNullable<Resource>, Field[K]>
            : never
          : T[K] extends {
                __type: "ComplexCalculation";
                __returnType: infer ReturnType;
              }
            ? NonNullable<ReturnType> extends TypedSchema
              ? null extends ReturnType
                ? InferResult<NonNullable<ReturnType>, Field[K]["fields"]> | null
                : InferResult<NonNullable<ReturnType>, Field[K]["fields"]>
              : ReturnType
            : NonNullable<T[K]> extends { __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
              ? NonNullable<T[K]> extends { __array: true }
                ? Field[K] extends any[]
                  ? null extends T[K]
                    ? Array<
                        UnionToIntersection<
                          {
                            [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends infer E
                              ? E extends TypedMapFields
                                ? E extends keyof NonNullable<T[K]>
                                  ? { [P in E]: NonNullable<T[K]>[P] }
                                  : never
                                : E extends Record<string, any>
                                  ? {
                                      [NestedKey in keyof E]: NestedKey extends keyof NonNullable<T[K]>
                                        ? NonNullable<NonNullable<T[K]>[NestedKey]> extends TypedSchema
                                          ? null extends NonNullable<T[K]>[NestedKey]
                                            ? InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]> | null
                                            : InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]>
                                          : never
                                        : never;
                                    }
                                  : E extends keyof NonNullable<T[K]>
                                    ? { [P in E]: NonNullable<T[K]>[P] }
                                    : never
                              : never;
                          }[number]
                        >
                      > | null
                    : Array<
                        UnionToIntersection<
                          {
                            [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends infer E
                              ? E extends TypedMapFields
                                ? E extends keyof NonNullable<T[K]>
                                  ? { [P in E]: NonNullable<T[K]>[P] }
                                  : never
                                : E extends Record<string, any>
                                  ? {
                                      [NestedKey in keyof E]: NestedKey extends keyof NonNullable<T[K]>
                                        ? NonNullable<NonNullable<T[K]>[NestedKey]> extends TypedSchema
                                          ? null extends NonNullable<T[K]>[NestedKey]
                                            ? InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]> | null
                                            : InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]>
                                          : never
                                        : never;
                                    }
                                  : E extends keyof NonNullable<T[K]>
                                    ? { [P in E]: NonNullable<T[K]>[P] }
                                    : never
                              : never;
                          }[number]
                        >
                      >
                  : never
                : Field[K] extends any[]
                  ? null extends T[K]
                    ? UnionToIntersection<
                        {
                          [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends infer E
                            ? E extends TypedMapFields
                              ? E extends keyof NonNullable<T[K]>
                                ? { [P in E]: NonNullable<T[K]>[P] }
                                : never
                              : E extends Record<string, any>
                                ? {
                                    [NestedKey in keyof E]: NestedKey extends keyof NonNullable<T[K]>
                                      ? NonNullable<NonNullable<T[K]>[NestedKey]> extends TypedSchema
                                        ? null extends NonNullable<T[K]>[NestedKey]
                                          ? InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]> | null
                                          : InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]>
                                        : never
                                      : never;
                                  }
                                : E extends keyof NonNullable<T[K]>
                                  ? { [P in E]: NonNullable<T[K]>[P] }
                                  : never
                            : never;
                        }[number]
                      > | null
                    : UnionToIntersection<
                        {
                          [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends infer E
                            ? E extends TypedMapFields
                              ? E extends keyof T[K]
                                ? { [P in E]: T[K][P] }
                                : never
                              : E extends Record<string, any>
                                ? {
                                    [NestedKey in keyof E]: NestedKey extends keyof NonNullable<T[K]>
                                      ? NonNullable<NonNullable<T[K]>[NestedKey]> extends TypedSchema
                                        ? null extends NonNullable<T[K]>[NestedKey]
                                          ? InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]> | null
                                          : InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]>
                                        : never
                                      : never;
                                  }
                                : E extends keyof NonNullable<T[K]>
                                  ? { [P in E]: NonNullable<T[K]>[P] }
                                  : never
                            : never;
                        }[number]
                      >
                  : never
              : T[K] extends { __type: "Union"; __primitiveFields: any }
                ? T[K] extends { __array: true }
                  ? Field[K] extends any[]
                    ? null extends T[K]
                      ? Array<InferUnionFieldValue<T[K], Field[K]>> | null
                      : Array<InferUnionFieldValue<T[K], Field[K]>>
                    : never
                  : Field[K] extends any[]
                    ? null extends T[K]
                      ? InferUnionFieldValue<T[K], Field[K]> | null
                      : InferUnionFieldValue<T[K], Field[K]>
                    : never
                  : NonNullable<T[K]> extends TypedSchema
                    ? null extends T[K]
                      ? InferResult<NonNullable<T[K]>, Field[K]> | null
                      : InferResult<NonNullable<T[K]>, Field[K]>
                    : never
          : never;
      }
    : never;

export type InferResult<
  T extends TypedSchema,
  SelectedFields extends UnifiedFieldSelection<T>[] | undefined,
> = SelectedFields extends undefined
  ? {}
  : SelectedFields extends []
  ? {}
  : SelectedFields extends UnifiedFieldSelection<T>[]
  ? UnionToIntersection<
      {
        [K in keyof SelectedFields]: InferFieldValue<T, SelectedFields[K]>;
      }[number]
    >
  : {};

// Pagination conditional types
// Checks if a page configuration object has any pagination parameters
export type HasPaginationParams<Page> =
  Page extends { offset: any } ? true :
  Page extends { after: any } ? true :
  Page extends { before: any } ? true :
  false;

// Infer which pagination type is being used from the page config
export type InferPaginationType<Page> =
  Page extends { offset: any } ? "offset" :
  Page extends { after: any } | { before: any } ? "keyset" :
  never;

// Returns either non-paginated (array) or paginated result based on page params
// For single pagination type support (offset-only or keyset-only)
// @ts-ignore
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export type ConditionalPaginatedResult<
  Page,
  RecordType,
  PaginatedType
> = Page extends undefined
  ? RecordType
  : HasPaginationParams<Page> extends true
    ? PaginatedType
    : RecordType;

// For actions supporting both offset and keyset pagination
// Infers the specific pagination type based on which params were passed
export type ConditionalPaginatedResultMixed<
  Page,
  RecordType,
  OffsetType,
  KeysetType
> = Page extends undefined
  ? RecordType
  : HasPaginationParams<Page> extends true
    ? InferPaginationType<Page> extends "offset"
      ? OffsetType
      : InferPaginationType<Page> extends "keyset"
        ? KeysetType
        : OffsetType | KeysetType  // Fallback to union if can't determine
    : RecordType;

export type SuccessDataFunc<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: true }
>["data"];


export type ErrorData<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: false }
>["errors"];

/**
 * Represents an error from an unsuccessful RPC call.
 *
 * This type matches the error structure defined in the AshTypescript.Rpc.Error protocol.
 *
 * @example
 * const error: AshRpcError = {
 *   type: "invalid_changes",
 *   message: "Invalid value for field %{field}",
 *   shortMessage: "Invalid changes",
 *   vars: { field: "email" },
 *   fields: ["email"],
 *   path: ["user", "email"],
 *   details: { suggestion: "Provide a valid email address" }
 * }
 */
export type AshRpcError = {
  /** Machine-readable error type (e.g., "invalid_changes", "not_found") */
  type: string;
  /** Full error message (may contain template variables like %{key}) */
  message: string;
  /** Concise version of the message */
  shortMessage: string;
  /** Variables to interpolate into the message template */
  vars: Record<string, any>;
  /** List of affected field names (for field-level errors) */
  fields: string[];
  /** Path to the error location in the data structure */
  path: string[];
  /** Optional map with extra details (e.g., suggestions, hints) */
  details?: Record<string, any>;
}

/**
 * Represents the result of a validation RPC call.
 *
 * All validation actions return this same structure, indicating either
 * successful validation or a list of validation errors.
 *
 * @example
 * // Successful validation
 * const result: ValidationResult = { success: true };
 *
 * // Failed validation
 * const result: ValidationResult = {
 *   success: false,
 *   errors: [
 *     {
 *       type: "required",
 *       message: "is required",
 *       shortMessage: "Required field",
 *       vars: { field: "email" },
 *       fields: ["email"],
 *       path: []
 *     }
 *   ]
 * };
 */
export type ValidationResult =
  | { success: true }
  | { success: false; errors: AshRpcError[]; };





// Helper Functions

/**
 * Configuration options for action RPC requests
 */
export interface ActionConfig {
  // Request data
  input?: Record<string, any>;
  identity?: any;
  fields?: Array<string | Record<string, any>>; // Field selection
  filter?: Record<string, any>; // Filter options (for reads)
  sort?: string; // Sort options
  page?:
    | {
        // Offset-based pagination
        limit?: number;
        offset?: number;
        count?: boolean;
      }
    | {
        // Keyset pagination
        limit?: number;
        after?: string;
        before?: string;
      };

  // Metadata
  metadataFields?: ReadonlyArray<string>;

  // HTTP customization
  headers?: Record<string, string>; // Custom headers
  fetchOptions?: RequestInit; // Fetch options (signal, cache, etc.)
  customFetch?: (
    input: RequestInfo | URL,
    init?: RequestInit,
  ) => Promise<Response>;

  // Multitenancy
  tenant?: string; // Tenant parameter

  // Hook context
  hookCtx?: Record<string, any>;
}

/**
 * Configuration options for validation RPC requests
 */
export interface ValidationConfig {
  // Request data
  input?: Record<string, any>;

  // HTTP customization
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (
    input: RequestInfo | URL,
    init?: RequestInit,
  ) => Promise<Response>;

  // Hook context
  hookCtx?: Record<string, any>;
}




/**
 * Gets the CSRF token from the page's meta tag
 * Returns null if no CSRF token is found
 */
export function getPhoenixCSRFToken(): string | null {
  return document
    ?.querySelector("meta[name='csrf-token']")
    ?.getAttribute("content") || null;
}

/**
 * Builds headers object with CSRF token for Phoenix applications
 * Returns headers object with X-CSRF-Token (if available)
 */
export function buildCSRFHeaders(headers: Record<string, string> = {}): Record<string, string> {
  const csrfToken = getPhoenixCSRFToken();
  if (csrfToken) {
    headers["X-CSRF-Token"] = csrfToken;
  }

  return headers;
}

/**
 * Internal helper function for making action RPC requests
 * Handles hooks, request configuration, fetch execution, and error handling
 * @param config Configuration matching ActionConfig
 */
export async function executeActionRpcRequest<T>(
  payload: Record<string, any>,
  config: ActionConfig
): Promise<T> {
    const processedConfig = config;

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/api/rpc/run", fetchOptions);
  const result = response.ok ? await response.json() : null;


  if (!response.ok) {
    return {
      success: false,
      errors: [
        {
          type: "network_error",
          message: `Network request failed: ${response.statusText}`,
          shortMessage: "Network error",
          vars: { statusCode: response.status, statusText: response.statusText },
          fields: [],
          path: [],
          details: { statusCode: response.status }
        }
      ],
    } as T;
  }

  return result as T;
}


/**
 * Internal helper function for making validation RPC requests
 * Handles hooks, request configuration, fetch execution, and error handling
 * @param config Configuration matching ValidationConfig
 */
export async function executeValidationRpcRequest<T>(
  payload: Record<string, any>,
  config: ValidationConfig
): Promise<T> {
    const processedConfig = config;

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/api/rpc/validate", fetchOptions);
  const result = response.ok ? await response.json() : null;


  if (!response.ok) {
    return {
      success: false,
      errors: [
        {
          type: "network_error",
          message: `Network request failed: ${response.statusText}`,
          shortMessage: "Network error",
          vars: { statusCode: response.status, statusText: response.statusText },
          fields: [],
          path: [],
          details: { statusCode: response.status }
        }
      ],
    } as T;
  }

  return result as T;
}









export type ListEnvironmentsFields = UnifiedFieldSelection<EnvironmentResourceSchema>[];


export type InferListEnvironmentsResult<
  Fields extends ListEnvironmentsFields | undefined,
  Page extends ListEnvironmentsConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<EnvironmentResourceSchema, Fields>>, {
  results: Array<InferResult<EnvironmentResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<EnvironmentResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListEnvironmentsConfig = {
  tenant?: string;
  fields: ListEnvironmentsFields;
  filter?: EnvironmentFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListEnvironmentsResult<Fields extends ListEnvironmentsFields, Page extends ListEnvironmentsConfig["page"] = undefined> = | { success: true; data: InferListEnvironmentsResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Environment records
 *
 * @ashActionType :read
 */
export async function listEnvironments<Fields extends ListEnvironmentsFields, Config extends ListEnvironmentsConfig = ListEnvironmentsConfig>(
  config: Config & { fields: Fields }
): Promise<ListEnvironmentsResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_environments",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListEnvironmentsResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read Environment records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListEnvironments(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_environments",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type CreateEnvironmentInput = {
  name: string;
  enabled?: boolean;
};

export type CreateEnvironmentFields = UnifiedFieldSelection<EnvironmentResourceSchema>[];

export type InferCreateEnvironmentResult<
  Fields extends CreateEnvironmentFields | undefined,
> = InferResult<EnvironmentResourceSchema, Fields>;

export type CreateEnvironmentResult<Fields extends CreateEnvironmentFields | undefined = undefined> = | { success: true; data: InferCreateEnvironmentResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new Environment
 *
 * @ashActionType :create
 */
export async function createEnvironment<Fields extends CreateEnvironmentFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateEnvironmentInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateEnvironmentResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateEnvironmentResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new Environment
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateCreateEnvironment(
  config: {
  tenant?: string;
  input: CreateEnvironmentInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "create_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type UpdateEnvironmentInput = {
  name?: string;
  enabled?: boolean;
};

export type UpdateEnvironmentFields = UnifiedFieldSelection<EnvironmentResourceSchema>[];

export type InferUpdateEnvironmentResult<
  Fields extends UpdateEnvironmentFields | undefined,
> = InferResult<EnvironmentResourceSchema, Fields>;

export type UpdateEnvironmentResult<Fields extends UpdateEnvironmentFields | undefined = undefined> = | { success: true; data: InferUpdateEnvironmentResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing Environment
 *
 * @ashActionType :update
 */
export async function updateEnvironment<Fields extends UpdateEnvironmentFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: UpdateEnvironmentInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateEnvironmentResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateEnvironmentResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing Environment
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateUpdateEnvironment(
  config: {
  tenant?: string;
  identity: UUID | string;
  input: UpdateEnvironmentInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "update_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}



export type DestroyEnvironmentResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Delete a Environment
 *
 * @ashActionType :destroy
 */
export async function destroyEnvironment(
  config: {
  tenant?: string;
  identity: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DestroyEnvironmentResult> {
  const payload = {
    action: "destroy_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeActionRpcRequest<DestroyEnvironmentResult>(
    payload,
    config
  );
}


/**
 * Validate: Delete a Environment
 *
 * @ashActionType :destroy
 * @validation true
 */
export async function validateDestroyEnvironment(
  config: {
  tenant?: string;
  identity: UUID | string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "destroy_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListCronsFields = UnifiedFieldSelection<CronResourceSchema>[];


export type InferListCronsResult<
  Fields extends ListCronsFields | undefined,
  Page extends ListCronsConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<CronResourceSchema, Fields>>, {
  results: Array<InferResult<CronResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<CronResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListCronsConfig = {
  tenant?: string;
  fields: ListCronsFields;
  filter?: CronFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListCronsResult<Fields extends ListCronsFields, Page extends ListCronsConfig["page"] = undefined> = | { success: true; data: InferListCronsResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Cron records
 *
 * @ashActionType :read
 */
export async function listCrons<Fields extends ListCronsFields, Config extends ListCronsConfig = ListCronsConfig>(
  config: Config & { fields: Fields }
): Promise<ListCronsResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_crons",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListCronsResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read Cron records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListCrons(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_crons",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type CreateCronInput = {
  name: string;
  crontabExpression: string;
  enabled?: boolean;
};

export type CreateCronFields = UnifiedFieldSelection<CronResourceSchema>[];

export type InferCreateCronResult<
  Fields extends CreateCronFields | undefined,
> = InferResult<CronResourceSchema, Fields>;

export type CreateCronResult<Fields extends CreateCronFields | undefined = undefined> = | { success: true; data: InferCreateCronResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new Cron
 *
 * @ashActionType :create
 */
export async function createCron<Fields extends CreateCronFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateCronInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateCronResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_cron",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateCronResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new Cron
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateCreateCron(
  config: {
  tenant?: string;
  input: CreateCronInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "create_cron",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type UpdateCronInput = {
  name?: string;
  crontabExpression?: string;
  enabled?: boolean;
};

export type UpdateCronFields = UnifiedFieldSelection<CronResourceSchema>[];

export type InferUpdateCronResult<
  Fields extends UpdateCronFields | undefined,
> = InferResult<CronResourceSchema, Fields>;

export type UpdateCronResult<Fields extends UpdateCronFields | undefined = undefined> = | { success: true; data: InferUpdateCronResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing Cron
 *
 * @ashActionType :update
 */
export async function updateCron<Fields extends UpdateCronFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: UpdateCronInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateCronResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_cron",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateCronResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing Cron
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateUpdateCron(
  config: {
  tenant?: string;
  identity: UUID | string;
  input: UpdateCronInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "update_cron",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}



export type DestroyCronResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Delete a Cron
 *
 * @ashActionType :destroy
 */
export async function destroyCron(
  config: {
  tenant?: string;
  identity: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DestroyCronResult> {
  const payload = {
    action: "destroy_cron",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeActionRpcRequest<DestroyCronResult>(
    payload,
    config
  );
}


/**
 * Validate: Delete a Cron
 *
 * @ashActionType :destroy
 * @validation true
 */
export async function validateDestroyCron(
  config: {
  tenant?: string;
  identity: UUID | string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "destroy_cron",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListCommandSchedulesFields = UnifiedFieldSelection<CommandScheduleResourceSchema>[];


export type InferListCommandSchedulesResult<
  Fields extends ListCommandSchedulesFields | undefined,
  Page extends ListCommandSchedulesConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<CommandScheduleResourceSchema, Fields>>, {
  results: Array<InferResult<CommandScheduleResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<CommandScheduleResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListCommandSchedulesConfig = {
  tenant?: string;
  fields: ListCommandSchedulesFields;
  filter?: CommandScheduleFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListCommandSchedulesResult<Fields extends ListCommandSchedulesFields, Page extends ListCommandSchedulesConfig["page"] = undefined> = | { success: true; data: InferListCommandSchedulesResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read CommandSchedule records
 *
 * @ashActionType :read
 */
export async function listCommandSchedules<Fields extends ListCommandSchedulesFields, Config extends ListCommandSchedulesConfig = ListCommandSchedulesConfig>(
  config: Config & { fields: Fields }
): Promise<ListCommandSchedulesResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_command_schedules",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListCommandSchedulesResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read CommandSchedule records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListCommandSchedules(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_command_schedules",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type CreateCommandScheduleInput = {
  commandId: UUID;
  enabled?: boolean;
};

export type CreateCommandScheduleFields = UnifiedFieldSelection<CommandScheduleResourceSchema>[];

export type InferCreateCommandScheduleResult<
  Fields extends CreateCommandScheduleFields | undefined,
> = InferResult<CommandScheduleResourceSchema, Fields>;

export type CreateCommandScheduleResult<Fields extends CreateCommandScheduleFields | undefined = undefined> = | { success: true; data: InferCreateCommandScheduleResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new CommandSchedule
 *
 * @ashActionType :create
 */
export async function createCommandSchedule<Fields extends CreateCommandScheduleFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateCommandScheduleInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateCommandScheduleResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_command_schedule",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateCommandScheduleResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new CommandSchedule
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateCreateCommandSchedule(
  config: {
  tenant?: string;
  input: CreateCommandScheduleInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "create_command_schedule",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type UpdateCommandScheduleInput = {
  commandId?: UUID;
  enabled?: boolean;
};

export type UpdateCommandScheduleFields = UnifiedFieldSelection<CommandScheduleResourceSchema>[];

export type InferUpdateCommandScheduleResult<
  Fields extends UpdateCommandScheduleFields | undefined,
> = InferResult<CommandScheduleResourceSchema, Fields>;

export type UpdateCommandScheduleResult<Fields extends UpdateCommandScheduleFields | undefined = undefined> = | { success: true; data: InferUpdateCommandScheduleResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing CommandSchedule
 *
 * @ashActionType :update
 */
export async function updateCommandSchedule<Fields extends UpdateCommandScheduleFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: UpdateCommandScheduleInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateCommandScheduleResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_command_schedule",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateCommandScheduleResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing CommandSchedule
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateUpdateCommandSchedule(
  config: {
  tenant?: string;
  identity: UUID | string;
  input: UpdateCommandScheduleInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "update_command_schedule",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}



export type DestroyCommandScheduleResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Delete a CommandSchedule
 *
 * @ashActionType :destroy
 */
export async function destroyCommandSchedule(
  config: {
  tenant?: string;
  identity: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DestroyCommandScheduleResult> {
  const payload = {
    action: "destroy_command_schedule",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeActionRpcRequest<DestroyCommandScheduleResult>(
    payload,
    config
  );
}


/**
 * Validate: Delete a CommandSchedule
 *
 * @ashActionType :destroy
 * @validation true
 */
export async function validateDestroyCommandSchedule(
  config: {
  tenant?: string;
  identity: UUID | string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "destroy_command_schedule",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListCommandScheduleEnvironmentsFields = UnifiedFieldSelection<CommandScheduleEnvironmentResourceSchema>[];


export type InferListCommandScheduleEnvironmentsResult<
  Fields extends ListCommandScheduleEnvironmentsFields | undefined,
  Page extends ListCommandScheduleEnvironmentsConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<CommandScheduleEnvironmentResourceSchema, Fields>>, {
  results: Array<InferResult<CommandScheduleEnvironmentResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<CommandScheduleEnvironmentResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListCommandScheduleEnvironmentsConfig = {
  tenant?: string;
  fields: ListCommandScheduleEnvironmentsFields;
  filter?: CommandScheduleEnvironmentFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListCommandScheduleEnvironmentsResult<Fields extends ListCommandScheduleEnvironmentsFields, Page extends ListCommandScheduleEnvironmentsConfig["page"] = undefined> = | { success: true; data: InferListCommandScheduleEnvironmentsResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read CommandScheduleEnvironment records
 *
 * @ashActionType :read
 */
export async function listCommandScheduleEnvironments<Fields extends ListCommandScheduleEnvironmentsFields, Config extends ListCommandScheduleEnvironmentsConfig = ListCommandScheduleEnvironmentsConfig>(
  config: Config & { fields: Fields }
): Promise<ListCommandScheduleEnvironmentsResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_command_schedule_environments",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListCommandScheduleEnvironmentsResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read CommandScheduleEnvironment records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListCommandScheduleEnvironments(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_command_schedule_environments",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type CreateCommandScheduleEnvironmentInput = {
  commandScheduleId: UUID;
  environmentId: UUID;
};

export type CreateCommandScheduleEnvironmentFields = UnifiedFieldSelection<CommandScheduleEnvironmentResourceSchema>[];

export type InferCreateCommandScheduleEnvironmentResult<
  Fields extends CreateCommandScheduleEnvironmentFields | undefined,
> = InferResult<CommandScheduleEnvironmentResourceSchema, Fields>;

export type CreateCommandScheduleEnvironmentResult<Fields extends CreateCommandScheduleEnvironmentFields | undefined = undefined> = | { success: true; data: InferCreateCommandScheduleEnvironmentResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new CommandScheduleEnvironment
 *
 * @ashActionType :create
 */
export async function createCommandScheduleEnvironment<Fields extends CreateCommandScheduleEnvironmentFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateCommandScheduleEnvironmentInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateCommandScheduleEnvironmentResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_command_schedule_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateCommandScheduleEnvironmentResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new CommandScheduleEnvironment
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateCreateCommandScheduleEnvironment(
  config: {
  tenant?: string;
  input: CreateCommandScheduleEnvironmentInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "create_command_schedule_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}



export type DestroyCommandScheduleEnvironmentResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Delete a CommandScheduleEnvironment
 *
 * @ashActionType :destroy
 */
export async function destroyCommandScheduleEnvironment(
  config: {
  tenant?: string;
  identity: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DestroyCommandScheduleEnvironmentResult> {
  const payload = {
    action: "destroy_command_schedule_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeActionRpcRequest<DestroyCommandScheduleEnvironmentResult>(
    payload,
    config
  );
}


/**
 * Validate: Delete a CommandScheduleEnvironment
 *
 * @ashActionType :destroy
 * @validation true
 */
export async function validateDestroyCommandScheduleEnvironment(
  config: {
  tenant?: string;
  identity: UUID | string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "destroy_command_schedule_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListCommandScheduleCronsFields = UnifiedFieldSelection<CommandScheduleCronResourceSchema>[];


export type InferListCommandScheduleCronsResult<
  Fields extends ListCommandScheduleCronsFields | undefined,
  Page extends ListCommandScheduleCronsConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<CommandScheduleCronResourceSchema, Fields>>, {
  results: Array<InferResult<CommandScheduleCronResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<CommandScheduleCronResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListCommandScheduleCronsConfig = {
  tenant?: string;
  fields: ListCommandScheduleCronsFields;
  filter?: CommandScheduleCronFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListCommandScheduleCronsResult<Fields extends ListCommandScheduleCronsFields, Page extends ListCommandScheduleCronsConfig["page"] = undefined> = | { success: true; data: InferListCommandScheduleCronsResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read CommandScheduleCron records
 *
 * @ashActionType :read
 */
export async function listCommandScheduleCrons<Fields extends ListCommandScheduleCronsFields, Config extends ListCommandScheduleCronsConfig = ListCommandScheduleCronsConfig>(
  config: Config & { fields: Fields }
): Promise<ListCommandScheduleCronsResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_command_schedule_crons",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListCommandScheduleCronsResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read CommandScheduleCron records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListCommandScheduleCrons(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_command_schedule_crons",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type CreateCommandScheduleCronInput = {
  commandScheduleId: UUID;
  cronId: UUID;
};

export type CreateCommandScheduleCronFields = UnifiedFieldSelection<CommandScheduleCronResourceSchema>[];

export type InferCreateCommandScheduleCronResult<
  Fields extends CreateCommandScheduleCronFields | undefined,
> = InferResult<CommandScheduleCronResourceSchema, Fields>;

export type CreateCommandScheduleCronResult<Fields extends CreateCommandScheduleCronFields | undefined = undefined> = | { success: true; data: InferCreateCommandScheduleCronResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new CommandScheduleCron
 *
 * @ashActionType :create
 */
export async function createCommandScheduleCron<Fields extends CreateCommandScheduleCronFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateCommandScheduleCronInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateCommandScheduleCronResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_command_schedule_cron",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateCommandScheduleCronResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new CommandScheduleCron
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateCreateCommandScheduleCron(
  config: {
  tenant?: string;
  input: CreateCommandScheduleCronInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "create_command_schedule_cron",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}



export type DestroyCommandScheduleCronResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Delete a CommandScheduleCron
 *
 * @ashActionType :destroy
 */
export async function destroyCommandScheduleCron(
  config: {
  tenant?: string;
  identity: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DestroyCommandScheduleCronResult> {
  const payload = {
    action: "destroy_command_schedule_cron",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeActionRpcRequest<DestroyCommandScheduleCronResult>(
    payload,
    config
  );
}


/**
 * Validate: Delete a CommandScheduleCron
 *
 * @ashActionType :destroy
 * @validation true
 */
export async function validateDestroyCommandScheduleCron(
  config: {
  tenant?: string;
  identity: UUID | string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "destroy_command_schedule_cron",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListVariablesFields = UnifiedFieldSelection<VariableResourceSchema>[];


export type InferListVariablesResult<
  Fields extends ListVariablesFields | undefined,
  Page extends ListVariablesConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<VariableResourceSchema, Fields>>, {
  results: Array<InferResult<VariableResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<VariableResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListVariablesConfig = {
  tenant?: string;
  fields: ListVariablesFields;
  filter?: VariableFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListVariablesResult<Fields extends ListVariablesFields, Page extends ListVariablesConfig["page"] = undefined> = | { success: true; data: InferListVariablesResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Variable records
 *
 * @ashActionType :read
 */
export async function listVariables<Fields extends ListVariablesFields, Config extends ListVariablesConfig = ListVariablesConfig>(
  config: Config & { fields: Fields }
): Promise<ListVariablesResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_variables",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListVariablesResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read Variable records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListVariables(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_variables",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type CreateVariableInput = {
  name: string;
};

export type CreateVariableFields = UnifiedFieldSelection<VariableResourceSchema>[];

export type InferCreateVariableResult<
  Fields extends CreateVariableFields | undefined,
> = InferResult<VariableResourceSchema, Fields>;

export type CreateVariableResult<Fields extends CreateVariableFields | undefined = undefined> = | { success: true; data: InferCreateVariableResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new Variable
 *
 * @ashActionType :create
 */
export async function createVariable<Fields extends CreateVariableFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateVariableInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateVariableResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_variable",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateVariableResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new Variable
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateCreateVariable(
  config: {
  tenant?: string;
  input: CreateVariableInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "create_variable",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type UpdateVariableInput = {
  name?: string;
};

export type UpdateVariableFields = UnifiedFieldSelection<VariableResourceSchema>[];

export type InferUpdateVariableResult<
  Fields extends UpdateVariableFields | undefined,
> = InferResult<VariableResourceSchema, Fields>;

export type UpdateVariableResult<Fields extends UpdateVariableFields | undefined = undefined> = | { success: true; data: InferUpdateVariableResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing Variable
 *
 * @ashActionType :update
 */
export async function updateVariable<Fields extends UpdateVariableFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: UpdateVariableInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateVariableResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_variable",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateVariableResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing Variable
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateUpdateVariable(
  config: {
  tenant?: string;
  identity: UUID | string;
  input: UpdateVariableInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "update_variable",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}



export type DestroyVariableResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Delete a Variable
 *
 * @ashActionType :destroy
 */
export async function destroyVariable(
  config: {
  tenant?: string;
  identity: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DestroyVariableResult> {
  const payload = {
    action: "destroy_variable",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeActionRpcRequest<DestroyVariableResult>(
    payload,
    config
  );
}


/**
 * Validate: Delete a Variable
 *
 * @ashActionType :destroy
 * @validation true
 */
export async function validateDestroyVariable(
  config: {
  tenant?: string;
  identity: UUID | string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "destroy_variable",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListVariableEnvironmentsFields = UnifiedFieldSelection<VariableEnvironmentResourceSchema>[];


export type InferListVariableEnvironmentsResult<
  Fields extends ListVariableEnvironmentsFields | undefined,
  Page extends ListVariableEnvironmentsConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<VariableEnvironmentResourceSchema, Fields>>, {
  results: Array<InferResult<VariableEnvironmentResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<VariableEnvironmentResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListVariableEnvironmentsConfig = {
  tenant?: string;
  fields: ListVariableEnvironmentsFields;
  filter?: VariableEnvironmentFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListVariableEnvironmentsResult<Fields extends ListVariableEnvironmentsFields, Page extends ListVariableEnvironmentsConfig["page"] = undefined> = | { success: true; data: InferListVariableEnvironmentsResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read VariableEnvironment records
 *
 * @ashActionType :read
 */
export async function listVariableEnvironments<Fields extends ListVariableEnvironmentsFields, Config extends ListVariableEnvironmentsConfig = ListVariableEnvironmentsConfig>(
  config: Config & { fields: Fields }
): Promise<ListVariableEnvironmentsResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_variable_environments",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListVariableEnvironmentsResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read VariableEnvironment records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListVariableEnvironments(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_variable_environments",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type CreateVariableEnvironmentInput = {
  variableId: UUID;
  environmentId: UUID;
  regularValue?: string | null;
  secretValue?: string;
};

export type CreateVariableEnvironmentFields = UnifiedFieldSelection<VariableEnvironmentResourceSchema>[];

export type InferCreateVariableEnvironmentResult<
  Fields extends CreateVariableEnvironmentFields | undefined,
> = InferResult<VariableEnvironmentResourceSchema, Fields>;

export type CreateVariableEnvironmentResult<Fields extends CreateVariableEnvironmentFields | undefined = undefined> = | { success: true; data: InferCreateVariableEnvironmentResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new VariableEnvironment
 *
 * @ashActionType :create
 */
export async function createVariableEnvironment<Fields extends CreateVariableEnvironmentFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateVariableEnvironmentInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateVariableEnvironmentResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_variable_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateVariableEnvironmentResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new VariableEnvironment
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateCreateVariableEnvironment(
  config: {
  tenant?: string;
  input: CreateVariableEnvironmentInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "create_variable_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type UpdateVariableEnvironmentInput = {
  regularValue?: string | null;
  secretValue?: string;
};

export type UpdateVariableEnvironmentFields = UnifiedFieldSelection<VariableEnvironmentResourceSchema>[];

export type InferUpdateVariableEnvironmentResult<
  Fields extends UpdateVariableEnvironmentFields | undefined,
> = InferResult<VariableEnvironmentResourceSchema, Fields>;

export type UpdateVariableEnvironmentResult<Fields extends UpdateVariableEnvironmentFields | undefined = undefined> = | { success: true; data: InferUpdateVariableEnvironmentResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing VariableEnvironment
 *
 * @ashActionType :update
 */
export async function updateVariableEnvironment<Fields extends UpdateVariableEnvironmentFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input?: UpdateVariableEnvironmentInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateVariableEnvironmentResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_variable_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateVariableEnvironmentResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing VariableEnvironment
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateUpdateVariableEnvironment(
  config: {
  tenant?: string;
  identity: UUID | string;
  input?: UpdateVariableEnvironmentInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "update_variable_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}



export type DestroyVariableEnvironmentResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Delete a VariableEnvironment
 *
 * @ashActionType :destroy
 */
export async function destroyVariableEnvironment(
  config: {
  tenant?: string;
  identity: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DestroyVariableEnvironmentResult> {
  const payload = {
    action: "destroy_variable_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeActionRpcRequest<DestroyVariableEnvironmentResult>(
    payload,
    config
  );
}


/**
 * Validate: Delete a VariableEnvironment
 *
 * @ashActionType :destroy
 * @validation true
 */
export async function validateDestroyVariableEnvironment(
  config: {
  tenant?: string;
  identity: UUID | string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "destroy_variable_environment",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListCommandsFields = UnifiedFieldSelection<CommandResourceSchema>[];


export type InferListCommandsResult<
  Fields extends ListCommandsFields | undefined,
  Page extends ListCommandsConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<CommandResourceSchema, Fields>>, {
  results: Array<InferResult<CommandResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<CommandResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListCommandsConfig = {
  tenant?: string;
  fields: ListCommandsFields;
  filter?: CommandFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListCommandsResult<Fields extends ListCommandsFields, Page extends ListCommandsConfig["page"] = undefined> = | { success: true; data: InferListCommandsResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Command records
 *
 * @ashActionType :read
 */
export async function listCommands<Fields extends ListCommandsFields, Config extends ListCommandsConfig = ListCommandsConfig>(
  config: Config & { fields: Fields }
): Promise<ListCommandsResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_commands",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListCommandsResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read Command records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListCommands(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_commands",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type CreateCommandInput = {
  name: string;
  shellCommand: string;
  enabled?: boolean;
  timeoutMs?: number;
};

export type CreateCommandFields = UnifiedFieldSelection<CommandResourceSchema>[];

export type InferCreateCommandResult<
  Fields extends CreateCommandFields | undefined,
> = InferResult<CommandResourceSchema, Fields>;

export type CreateCommandResult<Fields extends CreateCommandFields | undefined = undefined> = | { success: true; data: InferCreateCommandResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new Command
 *
 * @ashActionType :create
 */
export async function createCommand<Fields extends CreateCommandFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateCommandInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateCommandResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_command",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateCommandResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new Command
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateCreateCommand(
  config: {
  tenant?: string;
  input: CreateCommandInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "create_command",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type UpdateCommandInput = {
  name?: string;
  shellCommand?: string;
  enabled?: boolean;
  timeoutMs?: number;
};

export type UpdateCommandFields = UnifiedFieldSelection<CommandResourceSchema>[];

export type InferUpdateCommandResult<
  Fields extends UpdateCommandFields | undefined,
> = InferResult<CommandResourceSchema, Fields>;

export type UpdateCommandResult<Fields extends UpdateCommandFields | undefined = undefined> = | { success: true; data: InferUpdateCommandResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing Command
 *
 * @ashActionType :update
 */
export async function updateCommand<Fields extends UpdateCommandFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: UpdateCommandInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateCommandResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_command",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateCommandResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing Command
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateUpdateCommand(
  config: {
  tenant?: string;
  identity: UUID | string;
  input: UpdateCommandInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "update_command",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}



export type DestroyCommandResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Delete a Command
 *
 * @ashActionType :destroy
 */
export async function destroyCommand(
  config: {
  tenant?: string;
  identity: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DestroyCommandResult> {
  const payload = {
    action: "destroy_command",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeActionRpcRequest<DestroyCommandResult>(
    payload,
    config
  );
}


/**
 * Validate: Delete a Command
 *
 * @ashActionType :destroy
 * @validation true
 */
export async function validateDestroyCommand(
  config: {
  tenant?: string;
  identity: UUID | string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "destroy_command",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type EnqueueCommandRunInput = {
  id: UUID;
  environmentId?: UUID;
};

export type InferEnqueueCommandRunResult = UUID;

export type EnqueueCommandRunResult = | { success: true; data: InferEnqueueCommandRunResult; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Execute generic action on Command
 *
 * @ashActionType :action
 */
export async function enqueueCommandRun(
  config: {
  tenant?: string;
  input: EnqueueCommandRunInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<EnqueueCommandRunResult> {
  const payload = {
    action: "enqueue_command_run",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeActionRpcRequest<EnqueueCommandRunResult>(
    payload,
    config
  );
}


/**
 * Validate: Execute generic action on Command
 *
 * @ashActionType :action
 * @validation true
 */
export async function validateEnqueueCommandRun(
  config: {
  tenant?: string;
  input: EnqueueCommandRunInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "enqueue_command_run",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type EnqueueCommandRunInInput = {
  id: UUID;
  environmentId?: UUID;
  delaySeconds: number;
};

export type InferEnqueueCommandRunInResult = UUID;

export type EnqueueCommandRunInResult = | { success: true; data: InferEnqueueCommandRunInResult; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Execute generic action on Command
 *
 * @ashActionType :action
 */
export async function enqueueCommandRunIn(
  config: {
  tenant?: string;
  input: EnqueueCommandRunInInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<EnqueueCommandRunInResult> {
  const payload = {
    action: "enqueue_command_run_in",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeActionRpcRequest<EnqueueCommandRunInResult>(
    payload,
    config
  );
}


/**
 * Validate: Execute generic action on Command
 *
 * @ashActionType :action
 * @validation true
 */
export async function validateEnqueueCommandRunIn(
  config: {
  tenant?: string;
  input: EnqueueCommandRunInInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "enqueue_command_run_in",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type EnqueueCommandRunForceInput = {
  id: UUID;
  environmentId?: UUID;
};

export type InferEnqueueCommandRunForceResult = UUID;

export type EnqueueCommandRunForceResult = | { success: true; data: InferEnqueueCommandRunForceResult; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Execute generic action on Command
 *
 * @ashActionType :action
 */
export async function enqueueCommandRunForce(
  config: {
  tenant?: string;
  input: EnqueueCommandRunForceInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<EnqueueCommandRunForceResult> {
  const payload = {
    action: "enqueue_command_run_force",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeActionRpcRequest<EnqueueCommandRunForceResult>(
    payload,
    config
  );
}


/**
 * Validate: Execute generic action on Command
 *
 * @ashActionType :action
 * @validation true
 */
export async function validateEnqueueCommandRunForce(
  config: {
  tenant?: string;
  input: EnqueueCommandRunForceInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "enqueue_command_run_force",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type RetryCommandLastFailedInput = {
  id: UUID;
};

export type InferRetryCommandLastFailedResult = UUID;

export type RetryCommandLastFailedResult = | { success: true; data: InferRetryCommandLastFailedResult; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Execute generic action on Command
 *
 * @ashActionType :action
 */
export async function retryCommandLastFailed(
  config: {
  tenant?: string;
  input: RetryCommandLastFailedInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<RetryCommandLastFailedResult> {
  const payload = {
    action: "retry_command_last_failed",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeActionRpcRequest<RetryCommandLastFailedResult>(
    payload,
    config
  );
}


/**
 * Validate: Execute generic action on Command
 *
 * @ashActionType :action
 * @validation true
 */
export async function validateRetryCommandLastFailed(
  config: {
  tenant?: string;
  input: RetryCommandLastFailedInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "retry_command_last_failed",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListCommandJobEventsFields = UnifiedFieldSelection<CommandJobEventResourceSchema>[];


export type InferListCommandJobEventsResult<
  Fields extends ListCommandJobEventsFields | undefined,
  Page extends ListCommandJobEventsConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<CommandJobEventResourceSchema, Fields>>, {
  results: Array<InferResult<CommandJobEventResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<CommandJobEventResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListCommandJobEventsConfig = {
  tenant?: string;
  fields: ListCommandJobEventsFields;
  filter?: CommandJobEventFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListCommandJobEventsResult<Fields extends ListCommandJobEventsFields, Page extends ListCommandJobEventsConfig["page"] = undefined> = | { success: true; data: InferListCommandJobEventsResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read CommandJobEvent records
 *
 * @ashActionType :read
 */
export async function listCommandJobEvents<Fields extends ListCommandJobEventsFields, Config extends ListCommandJobEventsConfig = ListCommandJobEventsConfig>(
  config: Config & { fields: Fields }
): Promise<ListCommandJobEventsResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_command_job_events",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListCommandJobEventsResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read CommandJobEvent records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListCommandJobEvents(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_command_job_events",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListEventsForCommandInput = {
  commandId: UUID;
};

export type ListEventsForCommandFields = UnifiedFieldSelection<CommandJobEventResourceSchema>[];
export type InferListEventsForCommandResult<
  Fields extends ListEventsForCommandFields,
> = Array<InferResult<CommandJobEventResourceSchema, Fields>>;

export type ListEventsForCommandResult<Fields extends ListEventsForCommandFields> = | { success: true; data: InferListEventsForCommandResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read CommandJobEvent records
 *
 * @ashActionType :read
 */
export async function listEventsForCommand<Fields extends ListEventsForCommandFields>(
  config: {
  tenant?: string;
  input: ListEventsForCommandInput;
  fields: Fields;
  filter?: CommandJobEventFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ListEventsForCommandResult<Fields>> {
  const payload = {
    action: "list_events_for_command",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<ListEventsForCommandResult<Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Read CommandJobEvent records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListEventsForCommand(
  config: {
  tenant?: string;
  input: ListEventsForCommandInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_events_for_command",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type RetryCommandJobEventInput = {
  id: UUID;
};

export type InferRetryCommandJobEventResult = UUID;

export type RetryCommandJobEventResult = | { success: true; data: InferRetryCommandJobEventResult; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Execute generic action on CommandJobEvent
 *
 * @ashActionType :action
 */
export async function retryCommandJobEvent(
  config: {
  tenant?: string;
  input: RetryCommandJobEventInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<RetryCommandJobEventResult> {
  const payload = {
    action: "retry_command_job_event",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeActionRpcRequest<RetryCommandJobEventResult>(
    payload,
    config
  );
}


/**
 * Validate: Execute generic action on CommandJobEvent
 *
 * @ashActionType :action
 * @validation true
 */
export async function validateRetryCommandJobEvent(
  config: {
  tenant?: string;
  input: RetryCommandJobEventInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "retry_command_job_event",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListCommandJobsFields = UnifiedFieldSelection<CommandJobResourceSchema>[];


export type InferListCommandJobsResult<
  Fields extends ListCommandJobsFields | undefined,
  Page extends ListCommandJobsConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<CommandJobResourceSchema, Fields>>, {
  results: Array<InferResult<CommandJobResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<CommandJobResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListCommandJobsConfig = {
  tenant?: string;
  fields: ListCommandJobsFields;
  filter?: CommandJobFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListCommandJobsResult<Fields extends ListCommandJobsFields, Page extends ListCommandJobsConfig["page"] = undefined> = | { success: true; data: InferListCommandJobsResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read CommandJob records
 *
 * @ashActionType :read
 */
export async function listCommandJobs<Fields extends ListCommandJobsFields, Config extends ListCommandJobsConfig = ListCommandJobsConfig>(
  config: Config & { fields: Fields }
): Promise<ListCommandJobsResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_command_jobs",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListCommandJobsResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read CommandJob records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListCommandJobs(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_command_jobs",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type CreateCommandJobInput = {
  commandId: UUID;
  environmentId: UUID;
  cronId?: UUID | null;
  obanJobId?: number | null;
  shellCommand?: string;
  cronExpression?: string;
  startedAt?: UtcDateTimeUsec | null;
  finishedAt?: UtcDateTimeUsec | null;
};

export type CreateCommandJobFields = UnifiedFieldSelection<CommandJobResourceSchema>[];

export type InferCreateCommandJobResult<
  Fields extends CreateCommandJobFields | undefined,
> = InferResult<CommandJobResourceSchema, Fields>;

export type CreateCommandJobResult<Fields extends CreateCommandJobFields | undefined = undefined> = | { success: true; data: InferCreateCommandJobResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new CommandJob
 *
 * @ashActionType :create
 */
export async function createCommandJob<Fields extends CreateCommandJobFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateCommandJobInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateCommandJobResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_command_job",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateCommandJobResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new CommandJob
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateCreateCommandJob(
  config: {
  tenant?: string;
  input: CreateCommandJobInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "create_command_job",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type UpdateCommandJobInput = {
  obanJobId?: number | null;
  shellCommand?: string;
  cronExpression?: string;
  startedAt?: UtcDateTimeUsec | null;
  finishedAt?: UtcDateTimeUsec | null;
};

export type UpdateCommandJobFields = UnifiedFieldSelection<CommandJobResourceSchema>[];

export type InferUpdateCommandJobResult<
  Fields extends UpdateCommandJobFields | undefined,
> = InferResult<CommandJobResourceSchema, Fields>;

export type UpdateCommandJobResult<Fields extends UpdateCommandJobFields | undefined = undefined> = | { success: true; data: InferUpdateCommandJobResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing CommandJob
 *
 * @ashActionType :update
 */
export async function updateCommandJob<Fields extends UpdateCommandJobFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input?: UpdateCommandJobInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateCommandJobResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_command_job",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateCommandJobResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing CommandJob
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateUpdateCommandJob(
  config: {
  tenant?: string;
  identity: UUID | string;
  input?: UpdateCommandJobInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "update_command_job",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}



export type DestroyCommandJobResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Delete a CommandJob
 *
 * @ashActionType :destroy
 */
export async function destroyCommandJob(
  config: {
  tenant?: string;
  identity: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DestroyCommandJobResult> {
  const payload = {
    action: "destroy_command_job",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeActionRpcRequest<DestroyCommandJobResult>(
    payload,
    config
  );
}


/**
 * Validate: Delete a CommandJob
 *
 * @ashActionType :destroy
 * @validation true
 */
export async function validateDestroyCommandJob(
  config: {
  tenant?: string;
  identity: UUID | string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "destroy_command_job",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


